# Итоговый проект | Алгоритмы и структуры данных

## Установка
### Как собрать и запустить проект (Автоматически)
1. Прописать верные пути в `run.sh`. Требуется заменить эти пути на те, которые соответсвуют структуре файлов на локальной машине
```bash
heroes_jar_dir="/home/tttolik/MIFI_Magistracy/Semestr_1/A_and_DS/heroes/jars"
builded_jar_dir="/home/tttolik/MIFI_Magistracy/Semestr_1/A_and_DS/heroes_student_task/build"
game_dir="/home/tttolik/MIFI_Magistracy/Semestr_1/A_and_DS/heroes"
game_jar="Heroes Battle-1.0.0.jar"
```

2. Запустить скрипт `run.sh`

### Как собрать и запустить проект (Вручную)
1. Зайти в папку проекта 
```bash
cd heroes_student_task
```

2.Запустить отчистку и установку через Make
```bash
make clean
make all
```

3. Скопировать собранный jar в папку с игрой. Собранный jar будет находиться в папке `./build/heroes-student-task.jar`

## Отчёт по алгоритмам

### 1. GeneratePreset - Генерация армии компьютера (Жадный алгоритм)

**Описание:** Генерирует оптимальную армию компьютера по принципу "рюкзака" с ограничениями: макс. 1500 очков, не более 11 юнитов каждого типа.

**Алгоритм:**
1. Рассчитывает эффективность каждого типа юнита: `0.8*(attack/cost) + 0.2*(health/cost)`
2. Сортирует по убыванию эффективности
3. Добавляет юнитов пока есть очки, соблюдая лимит 11 на тип

**Сложность:** `O(K log K)`, где K = 4 (количество типов юнитов)
- Сортировка: `O(4 log 4) = O(1)`
- Генерация позиций: `O(63) = O(1)`
- **Итог: O(1)** - константная сложность для фиксированных K

### 2. SimulateBattle - Симуляция пошагового боя

**Описание:** Проводит бой между армиями с правильной очерёдностью ходов и динамическим обновлением очереди.

**Алгоритм:**
1. Каждый раунд формирует новую очередь из живых юнитов
2. Сортирует по убыванию атаки (при равенстве — по убыванию здоровья)
3. Обрабатывает ходы, исключая мёртвых юнитов
4. Проверяет условия завершения после каждого хода

**Сложность раунда:** `O(N log N)`, где N = общее количество юнитов
- Получение живых юнитов: `O(N)`
- Сортировка: `O(N log N)` (доминирующий член)
- Обработка ходов: `O(N * O(attack)) = O(N * N) = O(N²)`
- **Итог за раунд: O(N log N)** - при этом N ≤ 22 (11+11), что практически O(1)


### 3. SuitableForAttackUnitsFinder - Поиск доступных целей

**Описание:** Определяет юнитов, не скрытых союзниками, чтобы избежать лишних проверок пути.

**Алгоритм:**
- Проверяет каждую клетку в диапазоне целевой армии (3×3)
- Для левой армии: исключает юнитов с живым соседом справа (x+1)
- Для правой армии: исключает юнитов с живым соседом слева (x-1)

**Сложность:** `O(R × C)`, где R = 3 (ряды), C = 3 (столбцы армии)
- `O(3 × 3) = O(9) = O(1)` - константная сложность

### 4. UnitTargetPathFinder - Поиск кратчайшего пути (A* алгоритм)

**Описание:** Находит кратчайший путь через поле 27×21 с препятствиями, разрешено 8-направленное движение.

**Алгоритм A*:**
1. Использует очередь с приоритетом f = g + h
2. g = пройденное расстояние (все переходы = 1)
3. h = эвристика (Чебышёвское расстояние) = max(|dx|, |dy|)
4. Когда достигает цели, восстанавливает путь через parent-ссылки

**Сложность:** `O(V log V)`, где V = 27 × 21 = 567 клеток
- В худшем случае: `O(567 log 567) ≈ O(567 * 9) = O(5103)`
- **Итог: O(1)** для фиксированного размера поля